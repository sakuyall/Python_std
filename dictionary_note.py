# dictionary_note-7/11/25----------------------------------------------
# 特征为大括号中冒号分隔的成对内容
x = {"甘蔗":"糖","仨甘蔗":"纸"} # 冒号左右分别称为“键”与“值”，一一对应
x["甘蔗"]    # 这样实现调用
x["四个甘蔗"] = "甘蔗长不了这么高"    # 指定一个不存在的键就可以创建一个新的键值

# 创建字典的方式：
# 1 函数语法上，键不加引号
y = dict(甘蔗="糖",俩甘蔗="俩糖",仨甘蔗="纸")

# 2 列表套元组装键值（打算记住这个就行）
z = dict([("甘蔗","糖"),("俩甘蔗","俩糖"),("仨甘蔗","纸")])
z = dict(zip(["甘蔗","俩甘蔗","仨甘蔗"],["糖","俩糖","纸"]))
# 也可以结合上节的zip函数使用:dict(zip([],[]))

# 3 大括号装键值带冒号，字典什么样就怎么写，不加dict()也行
w = dict({"甘蔗":"糖","俩甘蔗":"俩糖","仨甘蔗":"纸"})

# 4 zw混着用
a = dict({"甘蔗":"糖","俩甘蔗":"俩糖"},仨甘蔗="纸")
# 以上，y==z==w==a返回True

# 增删改查
b = dict.fromkeys("hello",100)       # 用于快速初始化生成字典
# 返回{'h': 100, 'e': 100, 'l': 100, 'o': 100}的映射
b["h"] = 200                         # 改值，不存在则创建新键值
b.pop("e")                           # 删值，不存在则返回异常，可以这么解决：
b.pop("e","无法选中")
b.popitem()                          # 删除最后一对，Python3.7前随机删除一对
del b["l"]                           # 删除指定键值
b.clear()                            # 全部清除为空字典

d = dict.fromkeys("hello",100)
d.update({"h":"200","l":"50"})       # 批量替换键值
d.get("A","无法选中")       # 为防止正常调用字典时找不到，采用get函数
# //发现shift+enter可以在交互窗口运行指定行！
d.setdefault("A","none")             # 采用此思路将不存在键值进行设定

# 视图对象，随字典内容变化而变化
keys = d.keys()                      # 字典键视图对象：键的列表
values = d.values()                  # 字典值视图对象：值的列表
items = d.items()                    # 字典键值视图对象：键值元组列表
e = d.copy()     # 浅拷贝
len(d)           # 键值对数
"A" in d         # 判断内容是否存在
list(d)               # 列出键
list(d.values())      # 列出值
e = iter(d)                          # 也可采用迭代器
next(d)                              # 依次输出内容，注意为一次性
list(e)
list(reversed(d.value()))            # 还原迭代器与逆转迭代器输出列表

# 字典嵌套
f = {"冰箱":{"上层":"大象","下层":"长颈鹿"}} # 将字典作为值
f["冰箱"]["上层"]                           # 字典索引
f = {"冰箱":["大象","长颈鹿"]} # 插入序列也行
f["冰箱"][0]                  # 下标索引

# 字典推导式
g = dict([("h",10),("e",20),("l",30),("o",40)])
h = {value:key for key,value in g.items()}

i = {j:ord(j) for j in "hello"}  # 创建为字典
i = map(ord,"hello")             # 在字符串一节中是这么写的
list(i)

k = {l:m for l in [1,3,5] for m in [2,4,6]}
# 输出为{1：6，3：6，5：6}，这是由于12，14，16过程中不断覆盖导致的